#include <iostream>
#include <algorithm>

#include <althread/alcriticalsection.h>

#include "riseup.hpp"

const std::string RiseUp::moduleName = "RiseUp";
const std::string RiseUp::eventCallbackName = "eventCallback";

RiseUp::RiseUp(boost::shared_ptr<AL::ALBroker> b) : broker(b),
	memoryProxy(AL::ALMemoryProxy(b)),
	postureProxy(AL::ALRobotPostureProxy(b)),
	navigationProxy(AL::ALNavigationProxy(b)),
	motionProxy(AL::ALMotionProxy(b)), touchProxy(AL::ALTouchProxy(b)),
	ttsProxy(AL::ALTextToSpeechProxy(b)),
	callbackMutex(AL::ALMutex::createALMutex()),
	defaultTangentialSecurityDistance(motionProxy.getTangentialSecurityDistance()),
	defaultOrthogonalSecurityDistance(motionProxy.getOrthogonalSecurityDistance())
{
	/*
	 * Explicitly enables joints' stiffness optimisation, even though it
	 * should be enabled by default. The documentation describes it as the
	 * `Smart Stiffness Reflex`.
	 * This enables NAO to automatically control the current applied to the
	 * motors located on its joints in order to maintain the target posture
	 * using as little power as possible.
	 * WARNING: the torque/current/stiffness optimisation will only be
	 * enabled for the joints that did not have their stiffness manually
	 * configured by the user.
	 * It helps to save battery and to avoid problems with overheating
	 * joints.
	 */
	motionProxy.setSmartStiffnessEnabled(true);

	/*
	 * Enables the external collision protection
	 * Described in the documentation as `External collision protection
	 * reflex`.
	 * It depends on the ALNavigation module to be activated
	 * Disabling it requires the user's consent in the `Former NAO web
	 * configuration page`.
	 * The following protections are available:
	 * - LArm: the robot will stop moving if it detects that its left arm
	 *   would collide against an external object.
	 * - RArm: the robot will stop moving if it detects that its right arm
	 *   would collide against an external object.
	 * - Arms: the robot will stop moving if it detects that any of its arms
	 *   would collide against an external object.
	 * - Move: the robot will refuse to move if it detects that it would
	 *   collide against an external object.
	 * - All: all the previous collision protections are enabled.
	 * When an obstacle is detected and the movement is cancelled, the robot
	 * will trigger the following events:
	 * - ALMotion/Safety/ChainVelocityClipped
	 * - ALMotion/MoveFailed
	 */
	motionProxy.setExternalCollisionProtectionEnabled("All", true);

	/*
	 * Explicitly enables NAO's fall manager reflex
	 * Should be enabled by default, but the user may have modified the
	 * ALMotion preference (file /home/nao/.config/naoqi/ALMotion.xml).
	 * This allows NAO to sense that it is falling or that it might fall. In
	 * such a situation, the robot will enter a defensive posture to avoid
	 * hitting its head in the ground and will cut the current in the joints
	 * to allow the internal reduction gears to cushion the fall.
	 * This reflex does not protect NAO from falling from any position where
	 * both of its feet are not touching the ground. The protection is also
	 * disabled when NAO is in a posture other than those in the `stand`
	 * postural family.
	 */
	motionProxy.setFallManagerEnabled(true);

	/*
	 * Enables NAO self-collision reflex
	 * This method enables NAO to avoid colliding one or both of its arms
	 * while performing a move using a `joint` method. It is disabled during
	 * a move made using `Whole Body` or `Cartesian` methods.
	 * The following `move chains` can be protected against collision with
	 * the other parts of the robot:
	 * - LArm: left arm chain
	 *   - Joints: LShoulderPitch, LShoulderRoll, LElbowYaw, LElbowRoll,
	 *     LWristYaw
	 *   - Actuator: LHand
	 * - RArm right arm chain
	 *   - Joints: RShoulderPitch, RShoulderRoll, RElbowYaw, RElbowRoll,
	 *     RWristYaw
	 *   - Actuator: RHand
	 * - Arms: both the left arm and the right arm chains
	 */
	motionProxy.setCollisionProtectionEnabled("Arms", true);

	/*
	 * Enables the robot to react to events generated by ALDiagnosis and
	 * ALBodyTemperature modules.
	 * These modules raise events concerning the integrity of the robot's
	 * joints, CPU and sensors.
	 */
	motionProxy.setDiagnosisEffectEnabled(true);

	goToBrazilIfPossible();

	/*
	 * Subscribe to the events raised by ALTouch when the head touch sensors are triggered
	 * These events will trigger a callback that will redirect the events to private callbacks
	 */
	std::string frontHeadEventKey = "FrontTactilTouched";
	std::string middleHeadEventKey = "MiddleTactilTouched";
	std::string rearHeadEventKey = "RearTactilTouched";

	RiseUp::subscribe(frontHeadEventKey,
		&RiseUp::frontHeadTactilCallback);
	RiseUp::subscribe(middleHeadEventKey,
		&RiseUp::middleHeadTactilCallback);
	RiseUp::subscribe(rearHeadEventKey,
		&RiseUp::rearHeadTactilCallback);
}

RiseUp::~RiseUp()
{
	for (eventCallbackHandlerMap::iterator it =
		eventCallbackHandlers.begin();
		it != eventCallbackHandlers.end(); it++) {
		unsubscribe(it->first);
	}
}

void RiseUp::goToBrazilIfPossible()
{
	bool found = false;
	std::string languageToFind = "Brazilian";

	std::vector<std::string> availableLanguages = ttsProxy.getAvailableLanguages();

	for (std::vector<std::string>::const_iterator it = availableLanguages.begin();
		it != availableLanguages.end(); it++) {
		if (it->compare(languageToFind)) {
			found = true;
			break;
		}
	}

	if (found) {
		ttsProxy.setLanguage(languageToFind);
		std::cout << "NAO speaks PT-BR" << std::endl;
	} else {
		std::cout << "NAO remains speaking " << ttsProxy.getLanguage() << std::endl;
	}
}

void RiseUp::subscribe(const std::string key, const callbackHandlerPtr callback)
{
	memoryProxy.subscribeToEvent(key, moduleName, eventCallbackName);
	if (eventCallbackHandlers.count(key)) {
		std::cout << key << " already subscribed in this module";
		std::cout << std::endl;
	}
	
	eventCallbackHandlers[key] = callback;
	std::cout << "Subscribed to " << key << std::endl;
}

void RiseUp::unsubscribe(const std::string key)
{
	memoryProxy.unsubscribeToEvent(key, moduleName);
	std::cout << "Unsubscribed to " << key << std::endl;
	eventCallbackHandlers.erase(key);
}

void RiseUp::wakeUp()
{
	const std::string posture = "StandInit";
	const float speed = 0.5f;

	if (postureProxy.goToPosture(posture, speed))
		motionProxy.wakeUp();
	else
		std::cout << "Failed to go to posture " << posture << std::endl;
}

void RiseUp::rest()
{
	motionProxy.rest();
}

void RiseUp::eventCallback(const std::string &key,
	const AL::ALValue &value, const AL::ALValue &message)
{
	AL::ALCriticalSection section(callbackMutex);

	std::cout << "key: " << key << '\n';
	std::cout << "value: " << value << '\n';
	std::cout << "message: " << message << std::endl;

	eventCallbackHandlerMap::iterator it = eventCallbackHandlers.find(key);
	if (it != eventCallbackHandlers.end()) {
		callbackHandlerPtr p = it->second;
		(*this.*p)(value, message);
	} else {
		std::cerr << "Unknown event " << key << std::endl;
	}
}

void RiseUp::middleHeadTactilCallback(const AL::ALValue &value,
	const AL::ALValue &message)
{
	std::cout << "Resting NAO" << std::endl;
	rest();
}
void RiseUp::frontHeadTactilCallback(const AL::ALValue &value,
	const AL::ALValue &message)
{
	std::cout << "Waking up NAO" << std::endl;
	wakeUp();
}

void RiseUp::rearHeadTactilCallback(const AL::ALValue &value,
	const AL::ALValue &message)
{
	std::cout << "Toggle breath animation" << std::endl;

	bool breathEnabled = motionProxy.getBreathEnabled("Body");

	std::string msg = breathEnabled ? "Will breath" : "Will not breath";
	std::cout << msg << std::endl;

	motionProxy.setBreathEnabled("Body", !breathEnabled);
}

QI_REGISTER_MT_OBJECT(RiseUp, wakeUp, rest, eventCallback);
